"""
Solidity contract generation tools for ChainSage.

Provides template system for common contract patterns (ERC20, ERC721, Governance)
following research/solidity and research/openzeppelin patterns.
"""

import re
from typing import Dict, List, Optional, Any
from datetime import datetime
from ..agents.models import ContractType, GenerationRequest, GeneratedContract


class SolidityTemplate:
    """Base class for Solidity contract templates."""

    def __init__(self, name: str):
        self.name = name
        self.base_imports: List[str] = []
        self.security_features: Dict[str, str] = {}

    def generate(self, request: GenerationRequest) -> str:
        """Generate Solidity code from template."""
        raise NotImplementedError

    def get_estimated_gas(self) -> Optional[int]:
        """Estimate deployment gas cost."""
        return None

    def get_functions(self) -> List[Dict[str, Any]]:
        """Get list of contract functions with descriptions."""
        return []

    def get_events(self) -> List[Dict[str, Any]]:
        """Get list of contract events."""
        return []


class ERC20Template(SolidityTemplate):
    """
    ERC20 token template following research/openzeppelin patterns.

    Implements standard ERC20 functionality with OpenZeppelin imports
    and optional security features.
    """

    def __init__(self):
        super().__init__("ERC20")
        self.base_imports = [
            "@openzeppelin/contracts/token/ERC20/ERC20.sol",
            "@openzeppelin/contracts/access/Ownable.sol"
        ]
        self.security_features = {
            'pausable': "@openzeppelin/contracts/utils/Pausable.sol",
            'burnable': "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol",
            'mintable': "",  # Custom implementation
            'cap': "@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol",
            'snapshot': "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol",
            'votes': "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol"
        }

    def generate(self, request: GenerationRequest) -> str:
        """Generate ERC20 token contract."""
        # Parse contract name from specification
        contract_name = self._extract_contract_name(request.specification)
        if not contract_name:
            contract_name = "CustomToken"

        # Build imports
        imports = self._build_imports(request.security_features)

        # Build contract inheritance
        inheritance = self._build_inheritance(request.security_features)

        # Build constructor
        constructor = self._build_constructor(contract_name, request.security_features)

        # Build functions
        functions = self._build_functions(request.security_features)

        # Generate complete contract
        contract_code = f'''// SPDX-License-Identifier: MIT
pragma solidity {request.solidity_version};

{imports}

/**
 * @title {contract_name}
 * @dev {self._generate_description(request.specification)}
 *
 * Generated by ChainSage at {datetime.now().isoformat()}
 * Security features: {", ".join(request.security_features) if request.security_features else "Standard"}
 */
contract {contract_name} is {inheritance} {{
{constructor}

{functions}
}}'''

        return contract_code

    def _extract_contract_name(self, specification: str) -> str:
        """Extract contract name from specification."""
        # Simple pattern matching for contract names
        patterns = [
            r'(?:contract|token|coin)\s+(?:called|named)\s+(\w+)',
            r'(\w+)\s+(?:token|coin|contract)',
            r'create\s+(?:a|an)\s+(\w+)'
        ]

        for pattern in patterns:
            match = re.search(pattern, specification, re.IGNORECASE)
            if match:
                name = match.group(1)
                # Convert to PascalCase
                return ''.join(word.capitalize() for word in re.findall(r'\w+', name))

        return ""

    def _build_imports(self, security_features: List[str]) -> str:
        """Build import statements based on features."""
        imports = set(self.base_imports)

        for feature in security_features:
            if feature in self.security_features and self.security_features[feature]:
                imports.add(self.security_features[feature])

        # Add common security imports
        if any(feature in security_features for feature in ['pausable', 'mintable']):
            imports.add("@openzeppelin/contracts/utils/Pausable.sol")

        if 'reentrancy_guard' in security_features:
            imports.add("@openzeppelin/contracts/utils/ReentrancyGuard.sol")

        return '\n'.join(f'import "{imp}";' for imp in sorted(imports))

    def _build_inheritance(self, security_features: List[str]) -> str:
        """Build contract inheritance chain."""
        base_classes = ["ERC20", "Ownable"]

        if 'pausable' in security_features:
            base_classes.append("Pausable")
        if 'burnable' in security_features:
            base_classes.append("ERC20Burnable")
        if 'cap' in security_features:
            base_classes.append("ERC20Capped")
        if 'snapshot' in security_features:
            base_classes.append("ERC20Snapshot")
        if 'votes' in security_features:
            base_classes.append("ERC20Votes")
        if 'reentrancy_guard' in security_features:
            base_classes.append("ReentrancyGuard")

        return ", ".join(base_classes)

    def _build_constructor(self, contract_name: str, security_features: List[str]) -> str:
        """Build contract constructor."""
        symbol = contract_name[:4].upper()  # Simple symbol generation

        # Base constructor
        constructor_params = ["address initialOwner"]
        constructor_calls = [
            f'ERC20("{contract_name}", "{symbol}")',
            "Ownable(initialOwner)"
        ]

        # Add feature-specific constructor calls
        if 'cap' in security_features:
            constructor_params.append("uint256 cap")
            constructor_calls.append("ERC20Capped(cap)")

        if 'votes' in security_features:
            constructor_calls.append("ERC20Permit(name())")

        constructor = f'''    constructor({", ".join(constructor_params)})
        {" ".join(constructor_calls)}
    {{
        // Initial token distribution can be added here
        // _mint(initialOwner, initialSupply);
    }}'''

        return constructor

    def _build_functions(self, security_features: List[str]) -> str:
        """Build contract functions based on features."""
        functions = []

        # Standard mint function if mintable
        if 'mintable' in security_features:
            functions.append('''    /**
     * @dev Mint new tokens. Only callable by owner.
     * @param to The address to mint tokens to
     * @param amount The amount of tokens to mint
     */
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }''')

        # Pause/unpause functions if pausable
        if 'pausable' in security_features:
            functions.append('''    /**
     * @dev Pause all token transfers. Only callable by owner.
     */
    function pause() public onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause all token transfers. Only callable by owner.
     */
    function unpause() public onlyOwner {
        _unpause();
    }

    /**
     * @dev Override required by Pausable extension.
     */
    function _update(address from, address to, uint256 value)
        internal
        override
        whenNotPaused
    {
        super._update(from, to, value);
    }''')

        # Snapshot function
        if 'snapshot' in security_features:
            functions.append('''    /**
     * @dev Create a snapshot of current token balances.
     * @return The snapshot ID
     */
    function snapshot() public onlyOwner returns (uint256) {
        return _snapshot();
    }''')

        # Gas optimization note
        functions.append('''    /**
     * @dev Gas optimization: Override transfer functions if needed
     * Following research/solidity patterns for efficient transfers
     */''')

        return '\n\n'.join(functions)

    def _generate_description(self, specification: str) -> str:
        """Generate contract description from specification."""
        return f"ERC20 token contract generated from specification: {specification[:100]}..."

    def get_estimated_gas(self) -> Optional[int]:
        """Estimate deployment gas cost for ERC20 token."""
        return 1200000  # Typical ERC20 deployment cost

    def get_functions(self) -> List[Dict[str, Any]]:
        """Get list of contract functions."""
        return [
            {
                "name": "transfer",
                "description": "Transfer tokens to another address",
                "visibility": "public",
                "mutability": "nonpayable"
            },
            {
                "name": "approve",
                "description": "Approve spender to transfer tokens",
                "visibility": "public",
                "mutability": "nonpayable"
            },
            {
                "name": "balanceOf",
                "description": "Get token balance of address",
                "visibility": "public",
                "mutability": "view"
            }
        ]

    def get_events(self) -> List[Dict[str, Any]]:
        """Get list of contract events."""
        return [
            {
                "name": "Transfer",
                "description": "Emitted when tokens are transferred",
                "parameters": ["address indexed from", "address indexed to", "uint256 value"]
            },
            {
                "name": "Approval",
                "description": "Emitted when approval is granted",
                "parameters": ["address indexed owner", "address indexed spender", "uint256 value"]
            }
        ]


class ERC721Template(SolidityTemplate):
    """ERC721 NFT template following research/openzeppelin patterns."""

    def __init__(self):
        super().__init__("ERC721")
        self.base_imports = [
            "@openzeppelin/contracts/token/ERC721/ERC721.sol",
            "@openzeppelin/contracts/access/Ownable.sol"
        ]

    def generate(self, request: GenerationRequest) -> str:
        """Generate ERC721 NFT contract."""
        contract_name = self._extract_contract_name(request.specification) or "CustomNFT"
        symbol = contract_name[:4].upper()

        return f'''// SPDX-License-Identifier: MIT
pragma solidity {request.solidity_version};

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title {contract_name}
 * @dev ERC721 NFT contract generated from specification: {request.specification[:100]}...
 *
 * Generated by ChainSage at {datetime.now().isoformat()}
 */
contract {contract_name} is ERC721, Ownable {{
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;
    uint256 public maxSupply = 10000;

    constructor(address initialOwner)
        ERC721("{contract_name}", "{symbol}")
        Ownable(initialOwner)
    {{}}

    /**
     * @dev Mint NFT to specified address
     */
    function safeMint(address to) public onlyOwner {{
        require(_tokenIdCounter.current() < maxSupply, "Max supply reached");
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
    }}

    /**
     * @dev Get current token ID
     */
    function getCurrentTokenId() public view returns (uint256) {{
        return _tokenIdCounter.current();
    }}
}}'''

    def _extract_contract_name(self, specification: str) -> str:
        """Extract contract name from specification."""
        patterns = [
            r'(?:nft|nfts|token|collection)\s+(?:called|named)\s+(\w+)',
            r'(\w+)\s+(?:nft|collection)',
            r'create\s+(?:a|an)\s+(\w+)'
        ]

        for pattern in patterns:
            match = re.search(pattern, specification, re.IGNORECASE)
            if match:
                name = match.group(1)
                return ''.join(word.capitalize() for word in re.findall(r'\w+', name))

        return ""


class CustomTemplate(SolidityTemplate):
    """Custom contract template for general-purpose contracts."""

    def __init__(self):
        super().__init__("Custom")

    def generate(self, request: GenerationRequest) -> str:
        """Generate custom contract based on specification."""
        contract_name = self._extract_contract_name(request.specification) or "CustomContract"

        # Basic custom contract template
        return f'''// SPDX-License-Identifier: MIT
pragma solidity {request.solidity_version};

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title {contract_name}
 * @dev Custom contract generated from specification: {request.specification[:100]}...
 *
 * Generated by ChainSage at {datetime.now().isoformat()}
 */
contract {contract_name} is Ownable, ReentrancyGuard {{

    // State variables
    mapping(address => uint256) public userBalances;
    uint256 public totalBalance;

    // Events
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor(address initialOwner) Ownable(initialOwner) {{}}

    /**
     * @dev Deposit funds to the contract
     */
    function deposit() public payable nonReentrant {{
        require(msg.value > 0, "Must send some ether");

        userBalances[msg.sender] += msg.value;
        totalBalance += msg.value;

        emit Deposit(msg.sender, msg.value);
    }}

    /**
     * @dev Withdraw funds from the contract
     */
    function withdraw(uint256 amount) public nonReentrant {{
        require(userBalances[msg.sender] >= amount, "Insufficient balance");

        userBalances[msg.sender] -= amount;
        totalBalance -= amount;

        (bool success, ) = payable(msg.sender).call{{value: amount}}("");
        require(success, "Transfer failed");

        emit Withdrawal(msg.sender, amount);
    }}

    /**
     * @dev Get user balance
     */
    function getUserBalance(address user) public view returns (uint256) {{
        return userBalances[user];
    }}

    /**
     * @dev Emergency withdraw by owner
     */
    function emergencyWithdraw() public onlyOwner {{
        (bool success, ) = payable(owner()).call{{value: address(this).balance}}("");
        require(success, "Emergency withdrawal failed");
    }}
}}'''

    def _extract_contract_name(self, specification: str) -> str:
        """Extract contract name from specification."""
        patterns = [
            r'(?:contract|system)\s+(?:called|named)\s+(\w+)',
            r'(\w+)\s+(?:contract|system)',
            r'create\s+(?:a|an)\s+(\w+)'
        ]

        for pattern in patterns:
            match = re.search(pattern, specification, re.IGNORECASE)
            if match:
                name = match.group(1)
                return ''.join(word.capitalize() for word in re.findall(r'\w+', name))

        return ""


class SolidityGenerator:
    """
    Main Solidity contract generator using template patterns.

    Follows research/solidity patterns for contract structure
    and integrates with OpenZeppelin security features.
    """

    def __init__(self):
        self.templates: Dict[ContractType, SolidityTemplate] = {
            ContractType.ERC20: ERC20Template(),
            ContractType.ERC721: ERC721Template(),
            ContractType.CUSTOM: CustomTemplate(),
            # Additional templates can be added here
        }

    def generate_contract(self, request: GenerationRequest) -> GeneratedContract:
        """
        Generate complete Solidity contract from request.

        Args:
            request: Generation request with specification and requirements

        Returns:
            GeneratedContract with complete Solidity code and metadata
        """
        # Select appropriate template
        template = self.templates.get(request.contract_type, self.templates[ContractType.CUSTOM])

        # Generate Solidity code
        solidity_code = template.generate(request)

        # Extract contract name
        contract_name = self._extract_contract_name_from_code(solidity_code)

        # Generate explanation
        explanation = self._generate_explanation(request, template)

        # Generate security notes
        security_notes = self._generate_security_notes(request, template)

        # Get dependencies
        dependencies = self._extract_dependencies(solidity_code)

        return GeneratedContract(
            contract_name=contract_name,
            solidity_code=solidity_code,
            explanation=explanation,
            security_notes=security_notes,
            dependencies=dependencies,
            estimated_gas=template.get_estimated_gas(),
            functions=template.get_functions(),
            events=template.get_events()
        )

    def _extract_contract_name_from_code(self, solidity_code: str) -> str:
        """Extract contract name from generated code."""
        match = re.search(r'contract\s+(\w+)', solidity_code)
        return match.group(1) if match else "GeneratedContract"

    def _generate_explanation(self, request: GenerationRequest, template: SolidityTemplate) -> str:
        """Generate human-readable explanation of the contract."""
        explanation = f"This is a {template.name} contract generated based on your specification:\n\n"
        explanation += f"'{request.specification}'\n\n"
        explanation += f"Contract Type: {request.contract_type.value}\n"

        if request.security_features:
            explanation += f"Security Features: {', '.join(request.security_features)}\n"

        explanation += f"OpenZeppelin Integration: {'Enabled' if request.openzeppelin_integration else 'Disabled'}\n"
        explanation += f"Complexity Level: {request.max_complexity}/10\n"

        return explanation

    def _generate_security_notes(self, request: GenerationRequest, template: SolidityTemplate) -> List[str]:
        """Generate security notes and recommendations."""
        notes = [
            "Always test thoroughly on testnets before mainnet deployment",
            "Consider getting a professional security audit for production use",
            "Follow the principle of least privilege for access controls",
        ]

        if 'reentrancy_guard' in request.security_features:
            notes.append("ReentrancyGuard is used to prevent reentrancy attacks")

        if request.contract_type == ContractType.ERC20:
            notes.extend([
                "ERC20 tokens are fungible and follow the standard interface",
                "Consider implementing proper tokenomics and distribution mechanisms",
                "Be mindful of integer overflow/underflow (Solidity 0.8+ has built-in protection)"
            ])

        if request.contract_type == ContractType.ERC721:
            notes.extend([
                "ERC721 tokens are non-fungible with unique token IDs",
                "Consider implementing proper metadata and IPFS integration",
                "Be aware of gas costs for batch minting operations"
            ])

        return notes

    def _extract_dependencies(self, solidity_code: str) -> List[str]:
        """Extract OpenZeppelin and other dependencies from code."""
        dependencies = []

        # Extract import statements
        import_pattern = r'import\s+"([^"]+)"'
        imports = re.findall(import_pattern, solidity_code)

        for imp in imports:
            if "@openzeppelin" in imp:
                dependencies.append(imp)

        return dependencies

    def validate_solidity_syntax(self, code: str) -> tuple[bool, List[str]]:
        """
        Basic Solidity syntax validation.

        Returns:
            Tuple of (is_valid, error_messages)
        """
        errors = []

        # Check for pragma statement
        if not re.search(r'pragma\s+solidity', code):
            errors.append("Missing pragma solidity statement")

        # Check for contract definition
        if not re.search(r'contract\s+\w+', code):
            errors.append("No contract definition found")

        # Check for SPDX license
        if 'SPDX-License-Identifier' not in code:
            errors.append("Missing SPDX license identifier")

        # Check balanced braces
        open_braces = code.count('{')
        close_braces = code.count('}')
        if open_braces != close_braces:
            errors.append(f"Unbalanced braces: {open_braces} opening, {close_braces} closing")

        return len(errors) == 0, errors


if __name__ == "__main__":
    # Test contract generation
    generator = SolidityGenerator()

    # Test ERC20 generation
    request = GenerationRequest(
        specification="Create a MyToken ERC20 token with minting and burning capabilities",
        contract_type=ContractType.ERC20,
        security_features=["mintable", "burnable", "pausable"],
        openzeppelin_integration=True
    )

    contract = generator.generate_contract(request)
    print("✅ Generated ERC20 contract:")
    print(f"📄 Contract name: {contract.contract_name}")
    print(f"🔧 Functions: {len(contract.functions)}")
    print(f"📊 Events: {len(contract.events)}")
    print(f"⛽ Estimated gas: {contract.estimated_gas}")
    print(f"🛡️ Security notes: {len(contract.security_notes)}")